/*
 * Commentary on yacc source codes
 *   f1.c
 */
 
int TBITSET;
static int tbitset;	/* size of lookahead sets */
LOOKSETS *lkst;
static int lsetsize;

static int nlset = 0; 	/* next lookahead set index */
int nolook = 0; 	/* flag to suppress lookahead computations */
static LOOKSETS clset;  /* temporary storage for lookahead computations */

static ITEM *psmem, *zzmemsz;
static int new_pstsize = PSTSIZE;

	/* working set computations */

WSET *wsets;
int cwp;
static int wsetsz = 0;		/* number of WSET items in wsets block */

	/* state information */

int nstate = 0;			/* number of states */
static int nstatesz = NSTATES;	/* number of state space allocated	*/
ITEM **pstate;			/* ptr to descriptions of the states	*/
int *tystate;			/* contains type info about the states	*/
int *indgo;			/* index to the stored goto table	*/
static int *tmp_lset;
static int *tstates;		/* states generated by terminal gotos	*/
static int *ntstates;		/* states generated by non-term gotos	*/
static int *mstates;		/* chain of overflows of term/nonterm	*/
				/* generation lists			*/

	/* storage for the actions in the parser */

int *amem, *memp;		/* next free action table position */

	/* other storage areas */

int *temp1;		/* temp storate, indexed by terms+ntokens or states */
int lineno = 0;		/* current input line number */
int size;
static int fatfl = 1;  	/* if on, error is fatal */
static int nerrors = 0;	/* number of errors */

	/* storage for information about the nonterminals */

static int ***pres;		/* vector of pointers to productions	*/
				/* yielding each nonterminal		*/
static LOOKSETS **pfirst;	/* vector of pointers to first sets for	*/
				/* each nonterminal			*/
static int *pempty;		/* vector of nonterminals nontrivially	*/
				/* deriving e				*/
extern int nprodsz;

int
main(int argc, char *argv[])
{
	setup(argc, argv); /* initialize and read productions */
	
	TBITSET = NWORDS(ntoksz*LKFACTOR);
	tbitset = NWORDS(ntokens*LKFACTOR);
	mktbls();
	cpres(); 	/* make table of which productions yield a */
			/* given nonterminal */
	cempty(); 	/* make a table of which nonterminals can match	*/
			/* the empty string */

	cpfir(); 	/* make a table of firsts of nonterminals */		
	stagen();	/* generate the states 	*/
	output();  	/* write the states and the tables */
 	go2out();
	hideprod();		
	summary();
	callopt();
	others();
}

static void
mktbls()
{
	lkst = (LOOKSETS *) malloc(sizeof (LOOKSETS) * (INIT_LSIZE + 1));
	wsets = (WSET *) malloc(sizeof (WSET) * (nnontersz + 1));

	clset.lset = (int *)malloc(sizeof (int)*TBITSET);
	tstates = (int *)malloc(sizeof (int)*(ntoksz + 1));
	ntstates = (int *)malloc(sizeof (int)*(nnontersz + 1));
	temp1 = (int *)malloc(sizeof (int)*size);
	pres = (int ***)malloc(sizeof (int **)*(nnontersz + 2));
	pfirst = (LOOKSETS **)malloc(sizeof (LOOKSETS *)*(nnontersz + 2));
	pempty = (int *)malloc(sizeof (int)*(nnontersz + 1));

	pstate = (ITEM **)malloc(sizeof (ITEM *)*(nstatesz+2));
	tystate = (int *)malloc(sizeof (int)*nstatesz);
	indgo = (int *)malloc(sizeof (int)*nstatesz);
	mstates = (int *)malloc(sizeof (int)*nstatesz);
	defact = (int *)malloc(sizeof (int)*nstatesz);
	wsetsz = nnontersz + 1;
	lsetsize = INIT_LSIZE + 1;
}

/* put out other arrays, copy the parsers */
static void
others()
{
	warray("yyr1", levprd, nprod);
	aryfil(temp1, nprod, 0);
	PLOOP(1, i)
		temp1[i] = ((prdptr[i+1] - prdptr[i]-2) << 1) | had_act[i];
	warray("yyr2", temp1, nprod);
	aryfil(temp1, nstate, -10000000);
	TLOOP(i)
		for (j = tstates[i]; j != 0; j = mstates[j])
			temp1[j] = tokset[i].value;
	NTLOOP(i)
		for (j = ntstates[i]; j != 0; j = mstates[j])
			temp1[j] = -i;
	warray("yychk", temp1, nstate);

	warray("yydef", defact, nstate);
}

/* copies string q into p, returning next free char ptr */
static char *
chcopy(p, q)
char *p, *q;
{
}

/* creates output string for item pointed to by pp */
char *
writem(pp)
int *pp;
{
}

/* return a pointer to the name of symbol i */
char *
symnam(int i)
{
}

/* output the summary on the tty */
static void
summary()
{
}

/* write out error comment */
/*PRINTFLIKE1*/
void
error(char *s, ...)
{
}

/*
 * Print out a warning message.
 */
/*PRINTFLIKE2*/
void
warning(int flag, char *s, ...)
{
}

/* set elements 0 through n-1 to c */
void
aryfil(v, n, c)
int *v, n, c;
{
}

/* set a to the union of a and b */
/* return 1 if b is not a subset of a, 0 otherwise */
static int
setunion(a, b)
int *a, *b;
{
	int i, x, sub;

	in_func();
	d_trace("IO: y1 setunion()");
	out_func();
	
	sub = 0;
	SETLOOP(i) {
		*a = (x = *a) | *b++;
		if (*a++ != x)
			sub = 1;
	}
	
	return (sub);
}

static void
prlook(p)
LOOKSETS *p;
{
	int j, *pp;

	pp = p->lset;
	if (pp == 0)
		(void) fprintf(foutput, "\tNULL");
	else {
		(void) fprintf(foutput, " { ");
		TLOOP(j) {
			if (BIT(pp, j))
				(void) fprintf(foutput,  WSFMT("%s "),
				    symnam(j));
		}
		(void) fprintf(foutput,  "}");
	}
}

/*
 * compute an array with the beginnings of  productions yielding
 * given nonterminals
 * The array pres points to these lists
 * the array pyield has the lists: the total size is only NPROD+1
 */
static void
cpres()
{
	int **ptrpy;
	int **pyield;
	int c, j, i;
	
	/*
	 * 2/29/88 -
	 * nprodsz is the size of the tables describing the productions.
	 * Normally this will be NPROD unless the production tables have
	 * been expanded, in which case the tables will be NPROD * N(where
	 * N is the number of times the tables had to be expanded.)
	 */
	if ((pyield = (int **) malloc(sizeof (int *) * nprodsz)) == NULL)
		error(gettext(
		"cannot allocate space for pyield array"));

	ptrpy = pyield;

	NTLOOP(i) {
		c = i + NTBASE;
		pres[i] = ptrpy;
		fatfl = 0;  /* make undefined  symbols  nonfatal */
		PLOOP(0, j) {
			if (*prdptr[j] == c)  	/* linear search for all c's */
				*ptrpy++ =  prdptr[j] + 1;
		}
		if (pres[i] == ptrpy) { 		/* c not found */
			error(gettext(
			"undefined nonterminal: %s"),
			    nontrst[i].name);
		}
	}
	pres[i] = ptrpy;
	fatfl = 1;
	if (nerrors) {
		summary();
		exit(1);
	}
	if (ptrpy != &pyield[nprod])
		error(gettext(
		"internal Yacc error: pyield %d"),
		    ptrpy-&pyield[nprod]);
}

/* compute an array with the first of nonterminals */
static void
cpfir()
{
	int *p, **s, i, **t, ch, changes;
	
	in_func();
	d_trace("IN: y1 cpfir()");

	zzcwp = nnonter;
	NTLOOP(i) {
		aryfil(wsets[i].ws.lset, tbitset, 0);
		t = pres[i+1];
		/* initially fill the sets */
		for (s = pres[i]; s < t; ++s) {
			/* check if ch is non-terminal */
			for (p = *s; (ch = *p) > 0; ++p) {
				if (ch < NTBASE) { 	/* should be token */
					SETBIT(wsets[i].ws.lset, ch);
					break;
				} else if (!pempty[ch-NTBASE])
					break;
			}
		}
	}

	/* now, reflect transitivity */

	changes = 1;
	while (changes) {
		changes = 0;
		NTLOOP(i) {
			t = pres[i+1];
			for (s = pres[i]; s < t; ++s) {
				for (p = *s; (ch = (*p-NTBASE)) >= 0; ++p) {
					changes |= setunion(wsets[i].ws.lset,
					    wsets[ch].ws.lset);
					if (!pempty[ch])
						break;
				}
			}
		}
	}

	NTLOOP(i)
		pfirst[i] = flset(&wsets[i].ws);
	if (!indebug) {
	  	d_trace("OUT:y1 cpfir()");
		out_func();
		return;
	}
	if ((foutput != NULL)) {
		NTLOOP(i) {
			(void) fprintf(foutput, WSFMT("\n%s: "),
			    nontrst[i].name);
			prlook(pfirst[i]);
			(void) fprintf(foutput, " %d\n", pempty[i]);
		}
	}

	d_trace("OUT:y1 cpfir()");
	out_func();
}

/* sorts last state,and sees if it equals earlier ones. returns state number */
int
state(int c)
{
	int size1, size2;
	int i;
	ITEM *p1, *p2, *k, *l, *q1, *q2;
	in_func();
	d_trace("IO: y1 state()");
	out_func();
	
	p1 = pstate[nstate];
	p2 = pstate[nstate+1];
	if (p1 == p2)
		return (0); /* null state */
	/* sort the items */
	for (k = p2 - 1; k > p1; k--) {	/* make k the biggest */
		for (l = k-1; l >= p1; --l)
			if (l->pitem > k->pitem) {
				int *s;
				LOOKSETS *ss;
				s = k->pitem;
				k->pitem = l->pitem;
				l->pitem = s;
				ss = k->look;
				k->look = l->look;
				l->look = ss;
			}
	}
	size1 = p2 - p1; /* size of state */

	for (i = (c >= NTBASE) ? ntstates[c-NTBASE] : tstates[c];
	    i != 0; i = mstates[i]) {
		/* get ith state */
		q1 = pstate[i];
		q2 = pstate[i+1];
		size2 = q2 - q1;
		if (size1 != size2)
			continue;
		k = p1;
		for (l = q1; l < q2; l++) {
			if (l->pitem != k->pitem)
				break;
			++k;
		}
		if (l != q2)
			continue;
		/* found it */
		pstate[nstate+1] = pstate[nstate]; /* delete last state */
		/* fix up lookaheads */
		if (nolook)
			return (i);
		for (l = q1, k = p1; l < q2; ++l, ++k) {
			int s;
			SETLOOP(s)
				clset.lset[s] = l->look->lset[s];
			if (setunion(clset.lset, k->look->lset)) {
				tystate[i] = MUSTDO;
				/* register the new set */
				l->look = flset(&clset);
			}
		}
		return (i);
	}
	/* state is new */
	if (nolook)
		error(gettext(
		"yacc state/nolook error"));
	pstate[nstate+2] = p2;
	if (nstate+1 >= nstatesz)
		exp_states();
	if (c >= NTBASE) {
		mstates[nstate] = ntstates[c - NTBASE];
		ntstates[c - NTBASE] = nstate;
	} else {
		mstates[nstate] = tstates[c];
		tstates[c] = nstate;
	}
	tystate[nstate] = MUSTDO;
	return (nstate++);
}


void
putitem(ptr, lptr)
int *ptr;
LOOKSETS *lptr;
{
	ITEM *j;

	in_func();
	d_trace("IN: y1 putitem()");

	if (pidebug && (foutput != NULL))
		(void) fprintf(foutput,
			WSFMT("putitem(%s), state %d\n"), writem(ptr), nstate);
	j = pstate[nstate+1];
	j->pitem = ptr;
	if (!nolook)
		j->look = flset(lptr);
	pstate[nstate+1] = ++j;
	if (j > zzmemsz) {
		zzmemsz = j;
		if (zzmemsz >=  &psmem[new_pstsize])
			exp_psmem();
			/* error("out of state space"); */
	}

	d_trace("OUT:y1 putitem()");
	out_func();
}

/*
 * mark nonterminals which derive the empty string
 * also, look for nonterminals which don't derive any token strings
 */
static void
cempty()
{
#define	EMPTY 1
#define	WHOKNOWS 0
#define	OK 1
	int i, *p;
	
	in_func();
	d_trace("IN: y1 cempty()");
	
	/*
	 * first, use the array pempty to detect productions
	 * that can never be reduced
	 */

	/* set pempty to WHONOWS */
	aryfil(pempty, nnonter+1, WHOKNOWS);

	/*
	 * now, look at productions, marking nonterminals which
	 * derive something
	 */
	more:
	PLOOP(0, i) {
		if (pempty[*prdptr[i] - NTBASE])
			continue;
		for (p = prdptr[i] + 1; *p >= 0; ++p)
			if (*p >= NTBASE && pempty[*p-NTBASE] == WHOKNOWS)
				break;
		if (*p < 0) { /* production can be derived */
			pempty[*prdptr[i]-NTBASE] = OK;
			goto more;
		}
	}

	/* now, look at the nonterminals, to see if they are all OK */

	NTLOOP(i) {
		/*
		 * the added production rises or falls as the
		 * start symbol ...
		 */
		if (i == 0)
			continue;
		if (pempty[i] != OK) {
			fatfl = 0;
			error(gettext(
			"nonterminal %s never derives any token string"),
			    nontrst[i].name);
		}
	}

	if (nerrors) {
		summary();
		exit(1);
	}

	/*
	 * now, compute the pempty array, to see which nonterminals
	 * derive the empty string
	 */

	/* set pempty to WHOKNOWS */

	aryfil(pempty, nnonter+1, WHOKNOWS);

	/* loop as long as we keep finding empty nonterminals */

again:
	PLOOP(1, i) {
		/* not known to be empty */
		if (pempty[*prdptr[i]-NTBASE] == WHOKNOWS) {
			for (p = prdptr[i]+1;
			    *p >= NTBASE && pempty[*p-NTBASE] == EMPTY; ++p)
				;
			/* we have a nontrivially empty nonterminal */
			if (*p < 0) {
				pempty[*prdptr[i]-NTBASE] = EMPTY;
				goto again; /* got one ... try for another */
			}
		}
	}
	d_trace("OUT:y1 cempty()");
	out_func();
}

/* generate the states */
static int gsdebug = 0;
static void
stagen()
{
	int i, j;
	int c;
	register WSET *p, *q;

	/* initialize */
	in_func();
	d_trace("IN: y1 stagen()");

	nstate = 0;

	pstate[0] = pstate[1] = psmem;
	aryfil(clset.lset, tbitset, 0);
	putitem(prdptr[0] + 1, &clset);
	tystate[0] = MUSTDO;
	nstate = 1;
	pstate[2] = pstate[1];

	aryfil(amem, new_actsize, 0);

	/* now, the main state generation loop */

	more:
	SLOOP(i) {
		if (tystate[i] != MUSTDO)
			continue;
		tystate[i] = DONE;
		aryfil(temp1, nnonter + 1, 0);
		/* take state i, close it, and do gotos */
		closure(i);
		WSLOOP(wsets, p) { /* generate goto's */
			if (p->flag)
				continue;
			p->flag = 1;
			c = *(p->pitem);
			if (c <= 1) {
				if (pstate[i+1]-pstate[i] <= p-wsets)
					tystate[i] = MUSTLOOKAHEAD;
				continue;
			}
			/* do a goto on c */
			WSLOOP(p, q) {
				/* this item contributes to the goto */
				if (c == *(q->pitem)) {
					putitem(q->pitem + 1, &q->ws);
					q->flag = 1;
				}
			}
			if (c < NTBASE)
				(void) state(c);  /* register new state */
			else temp1[c-NTBASE] = state(c);
		}
		if (gsdebug && (foutput != NULL)) {
			(void) fprintf(foutput,  "%d: ", i);
			NTLOOP(j) {
				if (temp1[j])
					(void) fprintf(foutput,
					    WSFMT("%s %d, "), nontrst[j].name,
					    temp1[j]);
			}
			(void) fprintf(foutput, "\n");
		}
		indgo[i] = apack(&temp1[1], nnonter - 1) - 1;
		goto more; /* we have done one goto; do some more */
	}
	/* no more to do... stop */
	d_trace("OUT:y1 stagen()");
	out_func();
}

/* generate the closure of state i */
static int cldebug = 0; /* debugging flag for closure */

void
closure(int i)
{
	int c, ch, work, k;
	register WSET *u, *v;
	int *pi;
	int **s, **t;
	ITEM *q;
	register ITEM *p;
	int idx1 = 0;
	
	in_func();
	d_trace("IN: y1 closure()");
	
	++zzclose;

	/* first, copy kernel of state i to wsets */
	cwp = 0;
	ITMLOOP(i, p, q) {
		wsets[cwp].pitem = p->pitem;
		wsets[cwp].flag = 1;    /* this item must get closed */
		SETLOOP(k)
			wsets[cwp].ws.lset[k] = p->look->lset[k];
		WSBUMP(cwp);
	}

	/* now, go through the loop, closing each item */

	work = 1;
	while (work) {
		work = 0;
		/*
		 * WSLOOP(wsets, u) {
		 */
		for (idx1 = 0; idx1 < cwp; idx1++) {
			u = &wsets[idx1];
			if (u->flag == 0)
				continue;
			c = *(u->pitem);  /* dot is before c */
			if (c < NTBASE) {
				u->flag = 0;
				/*
				 * only interesting case is where . is
				 * before nonterminal
				 */
				continue;
			}

			/* compute the lookahead */
			aryfil(clset.lset, tbitset, 0);

			/* find items involving c */

			WSLOOP(u, v) {
				if (v->flag == 1 && *(pi = v->pitem) == c) {
					v->flag = 0;
					if (nolook)
						continue;
					while ((ch = *++pi) > 0) {
						/* terminal symbol */
						if (ch < NTBASE) {
							SETBIT(clset.lset, ch);
							break;
						}
						/* nonterminal symbol */
						(void) setunion(clset.lset,
						    pfirst[ch-NTBASE]->lset);
						if (!pempty[ch-NTBASE])
							break;
					}
					if (ch <= 0)
						(void) setunion(clset.lset,
						    v->ws.lset);
				}
			}

			/*  now loop over productions derived from c */

			c -= NTBASE; /* c is now nonterminal number */

			t = pres[c+1];
			for (s = pres[c]; s < t; ++s) {
				/* put these items into the closure */
				WSLOOP(wsets, v) { /* is the item there */
					/* yes, it is there */
					if (v->pitem == *s) {
						if (nolook)
							goto nexts;
						if (setunion(v->ws.lset,
						    clset.lset))
							v->flag = work = 1;
						goto nexts;
					}
				}

				/*  not there; make a new entry */
				if (cwp + 1 >= wsetsz)
					exp_wsets();

				wsets[cwp].pitem = *s;
				wsets[cwp].flag = 1;
				if (!nolook) {
					work = 1;
					SETLOOP(k)
						wsets[cwp].ws.lset[k] =
						    clset.lset[k];
				}
				WSBUMP(cwp);
				nexts:;
			}
		}
	}

	/* have computed closure; flags are reset; return */

	if (&wsets[cwp] > &wsets[zzcwp])
		zzcwp = cwp;
	if (cldebug && (foutput != NULL)) {
		(void) fprintf(foutput, "\nState %d, nolook = %d\n", i, nolook);
		WSLOOP(wsets, u) {
			if (u->flag)
				(void) fprintf(foutput, "flag set!\n");
			u->flag = 0;
			(void) fprintf(foutput, WSFMT("\t%s"),
			    writem(u->pitem));
			prlook(&u->ws);
			(void) fprintf(foutput,  "\n");
		}
	}
	
	d_trace("OUT:y1 closure()");
	out_func();
}

static LOOKSETS *
flset(LOOKSETS *p)
{
	/* decide if the lookahead set pointed to by p is known */
	/* return pointer to a perminent location for the set */

	int j, *w;
	int *u, *v;
	register LOOKSETS *q;

	in_func();
	d_trace("IN: y1 flset()");

	for (q = &lkst[nlset]; q-- > lkst; ) {
		u = p->lset;
		v = q->lset;
		w = & v[tbitset];
		while (v < w)
			if (*u++ != *v++)
				goto more;
		/* we have matched */
		d_trace("OUT:y1 flset(1)");
		out_func();
		return (q);
		more:;
	}
	/* add a new one */
	q = &lkst[nlset++];
	if (nlset >= lsetsize) {
		exp_lkst();
		q = &lkst[nlset++];
	}
	SETLOOP(j) q->lset[j] = p->lset[j];
	d_trace("OUT:y1 flset(2)");
	out_func();
	return (q);
}

static void
exp_lkst()
{
}

static void
exp_wsets()
{
}

static void
exp_states()
{
}

static void
exp_psmem()
{
}
